   1               	# 1 "usbdrv/usbdrvasm.S"
   1               	/* Name: usbdrvasm.S
   0               	
   0               	
   2               	* Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-06-13
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id$
   9               	 */
  10               	
  11               	/*
  12               	General Description:
  13               	This module is the assembler part of the USB driver. This file contains
  14               	general code (preprocessor acrobatics and CRC computation) and then includes
  15               	the file appropriate for the given clock rate.
  16               	*/
  17               	
  18               	#include "iarcompat.h"
   1               	/* Name: iarcompat.h
  19               	TEMS_ASM__
  20               	    /* configs for io.h */
  21               	#   define __SFR_OFFSET 0
  22               	#   define _VECTOR(N)   __vector_ ## N   /* io.h does not define this for asm */
  23               	#   include <avr/io.h> /* for CPU I/O register definitions and vectors */
   1               	/* Copyright (c) 2002,2003,2005,2006,2007 Marek Michalkiewicz, Joerg Wunsch
   2               	   Copyright (c) 2007 Eric B. Weddington
   3               	   All rights reserved.
   4               	
   5               	   Redistribution and use in source and binary forms, with or without
   6               	   modification, are permitted provided that the following conditions are met:
   7               	
   8               	   * Redistributions of source code must retain the above copyright
   9               	     notice, this list of conditions and the following disclaimer.
  10               	
  11               	   * Redistributions in binary form must reproduce the above copyright
  12               	     notice, this list of conditions and the following disclaimer in
  13               	     the documentation and/or other materials provided with the
  14               	     distribution.
  15               	
  16               	   * Neither the name of the copyright holders nor the names of
  17               	     contributors may be used to endorse or promote products derived
  18               	     from this software without specific prior written permission.
  19               	
  20               	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21               	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22               	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23               	  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24               	  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25               	  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26               	  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27               	  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28               	  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29               	  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30               	  POSSIBILITY OF SUCH DAMAGE. */
  31               	
  32               	/* $Id: io.h,v 1.52.2.28 2009/12/20 17:02:53 arcanum Exp $ */
  33               	
  34               	/** \file */
  35               	/** \defgroup avr_io <avr/io.h>: AVR device-specific IO definitions
  36               	    \code #include <avr/io.h> \endcode
  37               	
  38               	    This header file includes the apropriate IO definitions for the
  39               	    device that has been specified by the <tt>-mmcu=</tt> compiler
  40               	    command-line switch.  This is done by diverting to the appropriate
  41               	    file <tt>&lt;avr/io</tt><em>XXXX</em><tt>.h&gt;</tt> which should
  42               	    never be included directly.  Some register names common to all
  43               	    AVR devices are defined directly within <tt>&lt;avr/common.h&gt;</tt>,
  44               	    which is included in <tt>&lt;avr/io.h&gt;</tt>,
  45               	    but most of the details come from the respective include file.
  46               	
  47               	    Note that this file always includes the following files:
  48               	    \code 
  49               	    #include <avr/sfr_defs.h>
  50               	    #include <avr/portpins.h>
  51               	    #include <avr/common.h>
  52               	    #include <avr/version.h>
  53               	    \endcode
  54               	    See \ref avr_sfr for more details about that header file.
  55               	
  56               	    Included are definitions of the IO register set and their
  57               	    respective bit values as specified in the Atmel documentation.
  58               	    Note that inconsistencies in naming conventions,
  59               	    so even identical functions sometimes get different names on
  60               	    different devices.
  61               	
  62               	    Also included are the specific names useable for interrupt
  63               	    function definitions as documented
  64               	    \ref avr_signames "here".
  65               	
  66               	    Finally, the following macros are defined:
  67               	
  68               	    - \b RAMEND
  69               	    <br>
  70               	    The last on-chip RAM address.
  71               	    <br>
  72               	    - \b XRAMEND
  73               	    <br>
  74               	    The last possible RAM location that is addressable. This is equal to 
  75               	    RAMEND for devices that do not allow for external RAM. For devices 
  76               	    that allow external RAM, this will be larger than RAMEND.
  77               	    <br>
  78               	    - \b E2END
  79               	    <br>
  80               	    The last EEPROM address.
  81               	    <br>
  82               	    - \b FLASHEND
  83               	    <br>
  84               	    The last byte address in the Flash program space.
  85               	    <br>
  86               	    - \b SPM_PAGESIZE
  87               	    <br>
  88               	    For devices with bootloader support, the flash pagesize
  89               	    (in bytes) to be used for the \c SPM instruction. 
  90               	    - \b E2PAGESIZE
  91               	    <br>
  92               	    The size of the EEPROM page.
  93               	    
  94               	*/
  95               	
  96               	#ifndef _AVR_IO_H_
  97               	#define _AVR_IO_H_
  98               	
  99               	#include <avr/sfr_defs.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz <marekm@amelek.gda.pl>
 100               	
 101               	#if defined (__AVR_AT94K__)
 102               	#  include <avr/ioat94k.h>
 103               	#elif defined (__AVR_AT43USB320__)
 104               	#  include <avr/io43u32x.h>
 105               	#elif defined (__AVR_AT43USB355__)
 106               	#  include <avr/io43u35x.h>
 107               	#elif defined (__AVR_AT76C711__)
 108               	#  include <avr/io76c711.h>
 109               	#elif defined (__AVR_AT86RF401__)
 110               	#  include <avr/io86r401.h>
 111               	#elif defined (__AVR_AT90PWM1__)
 112               	#  include <avr/io90pwm1.h>
 113               	#elif defined (__AVR_AT90PWM2__)
 114               	#  include <avr/io90pwmx.h>
 115               	#elif defined (__AVR_AT90PWM2B__)
 116               	#  include <avr/io90pwm2b.h>
 117               	#elif defined (__AVR_AT90PWM3__)
 118               	#  include <avr/io90pwmx.h>
 119               	#elif defined (__AVR_AT90PWM3B__)
 120               	#  include <avr/io90pwm3b.h>
 121               	#elif defined (__AVR_AT90PWM216__)
 122               	#  include <avr/io90pwm216.h>
 123               	#elif defined (__AVR_AT90PWM316__)
 124               	#  include <avr/io90pwm316.h>
 125               	#elif defined (__AVR_AT90PWM81__)
 126               	#  include <avr/io90pwm81.h>
 127               	#elif defined (__AVR_ATmega8U2__)
 128               	#  include <avr/iom8u2.h>
 129               	#elif defined (__AVR_ATmega16M1__)
 130               	#  include <avr/iom16m1.h>
 131               	#elif defined (__AVR_ATmega16U2__)
 132               	#  include <avr/iom16u2.h>
 133               	#elif defined (__AVR_ATmega16U4__)
 134               	#  include <avr/iom16u4.h>
 135               	#elif defined (__AVR_ATmega32C1__)
 136               	#  include <avr/iom32c1.h>
 137               	#elif defined (__AVR_ATmega32M1__)
 138               	#  include <avr/iom32m1.h>
 139               	#elif defined (__AVR_ATmega32U2__)
 140               	#  include <avr/iom32u2.h>
 141               	#elif defined (__AVR_ATmega32U4__)
 142               	#  include <avr/iom32u4.h>
 143               	#elif defined (__AVR_ATmega32U6__)
 144               	#  include <avr/iom32u6.h>
 145               	#elif defined (__AVR_ATmega64C1__)
 146               	#  include <avr/iom64c1.h>
 147               	#elif defined (__AVR_ATmega64M1__)
 148               	#  include <avr/iom64m1.h>
 149               	#elif defined (__AVR_ATmega128__)
 150               	#  include <avr/iom128.h>
 151               	#elif defined (__AVR_ATmega1280__)
 152               	#  include <avr/iom1280.h>
 153               	#elif defined (__AVR_ATmega1281__)
 154               	#  include <avr/iom1281.h>
 155               	#elif defined (__AVR_ATmega1284P__)
 156               	#  include <avr/iom1284p.h>
 157               	#elif defined (__AVR_ATmega128RFA1__)
 158               	#  include <avr/iom128rfa1.h>
 159               	#elif defined (__AVR_ATmega2560__)
 160               	#  include <avr/iom2560.h>
 161               	#elif defined (__AVR_ATmega2561__)
 162               	#  include <avr/iom2561.h>
 163               	#elif defined (__AVR_AT90CAN32__)
 164               	#  include <avr/iocan32.h>
 165               	#elif defined (__AVR_AT90CAN64__)
 166               	#  include <avr/iocan64.h>
 167               	#elif defined (__AVR_AT90CAN128__)
 168               	#  include <avr/iocan128.h>
 169               	#elif defined (__AVR_AT90USB82__)
 170               	#  include <avr/iousb82.h>
 171               	#elif defined (__AVR_AT90USB162__)
 172               	#  include <avr/iousb162.h>
 173               	#elif defined (__AVR_AT90USB646__)
 174               	#  include <avr/iousb646.h>
 175               	#elif defined (__AVR_AT90USB647__)
 176               	#  include <avr/iousb647.h>
 177               	#elif defined (__AVR_AT90USB1286__)
 178               	#  include <avr/iousb1286.h>
 179               	#elif defined (__AVR_AT90USB1287__)
 180               	#  include <avr/iousb1287.h>
 181               	#elif defined (__AVR_ATmega64__)
 182               	#  include <avr/iom64.h>
 183               	#elif defined (__AVR_ATmega640__)
 184               	#  include <avr/iom640.h>
 185               	#elif defined (__AVR_ATmega644__) || defined (__AVR_ATmega644A__)
 186               	#  include <avr/iom644.h>
 187               	#elif defined (__AVR_ATmega644P__)
 188               	#  include <avr/iom644p.h>
 189               	#elif defined (__AVR_ATmega644PA__)
 190               	#  include <avr/iom644pa.h>
 191               	#elif defined (__AVR_ATmega645__) || defined (__AVR_ATmega645A__) || defined (__AVR_ATmega645P__)
 192               	#  include <avr/iom645.h>
 193               	#elif defined (__AVR_ATmega6450__) || defined (__AVR_ATmega6450A__) || defined (__AVR_ATmega6450P__
 194               	#  include <avr/iom6450.h>
 195               	#elif defined (__AVR_ATmega649__) || defined (__AVR_ATmega649A__)
 196               	#  include <avr/iom649.h>
 197               	#elif defined (__AVR_ATmega6490__) || defined (__AVR_ATmega6490A__) || defined (__AVR_ATmega6490P__
 198               	#  include <avr/iom6490.h>
 199               	#elif defined (__AVR_ATmega649P__)
 200               	#  include <avr/iom649p.h>
 201               	#elif defined (__AVR_ATmega64HVE__)
 202               	#  include <avr/iom64hve.h>
 203               	#elif defined (__AVR_ATmega103__)
 204               	#  include <avr/iom103.h>
 205               	#elif defined (__AVR_ATmega32__)
 206               	#  include <avr/iom32.h>
 207               	#elif defined (__AVR_ATmega323__)
 208               	#  include <avr/iom323.h>
 209               	#elif defined (__AVR_ATmega324P__) || defined (__AVR_ATmega324A__)
 210               	#  include <avr/iom324.h>
 211               	#elif defined (__AVR_ATmega324PA__)
 212               	#  include <avr/iom324pa.h>
 213               	#elif defined (__AVR_ATmega325__)
 214               	#  include <avr/iom325.h>
 215               	#elif defined (__AVR_ATmega325P__)
 216               	#  include <avr/iom325.h>
 217               	#elif defined (__AVR_ATmega3250__)
 218               	#  include <avr/iom3250.h>
 219               	#elif defined (__AVR_ATmega3250P__)
 220               	#  include <avr/iom3250.h>
 221               	#elif defined (__AVR_ATmega328P__) || defined (__AVR_ATmega328__)
 222               	#  include <avr/iom328p.h>
 223               	#elif defined (__AVR_ATmega329__)
 224               	#  include <avr/iom329.h>
 225               	#elif defined (__AVR_ATmega329P__) || defined (__AVR_ATmega329PA__)
 226               	#  include <avr/iom329.h>
 227               	#elif defined (__AVR_ATmega3290__)
 228               	#  include <avr/iom3290.h>
 229               	#elif defined (__AVR_ATmega3290P__)
 230               	#  include <avr/iom3290.h>
 231               	#elif defined (__AVR_ATmega32HVB__)
 232               	#  include <avr/iom32hvb.h>
 233               	#elif defined (__AVR_ATmega406__)
 234               	#  include <avr/iom406.h>
 235               	#elif defined (__AVR_ATmega16__)
 236               	#  include <avr/iom16.h>
 237               	#elif defined (__AVR_ATmega16A__)
 238               	#  include <avr/iom16a.h>
 239               	#elif defined (__AVR_ATmega161__)
 240               	#  include <avr/iom161.h>
 241               	#elif defined (__AVR_ATmega162__)
 242               	#  include <avr/iom162.h>
 243               	#elif defined (__AVR_ATmega163__)
 244               	#  include <avr/iom163.h>
 245               	#elif defined (__AVR_ATmega164P__) || defined (__AVR_ATmega164A__)
 246               	#  include <avr/iom164.h>
 247               	#elif defined (__AVR_ATmega165__) || defined (__AVR_ATmega165A__)
 248               	#  include <avr/iom165.h>
 249               	#elif defined (__AVR_ATmega165P__)
 250               	#  include <avr/iom165p.h>
 251               	#elif defined (__AVR_ATmega168__) || defined (__AVR_ATmega168A__)
 252               	#  include <avr/iom168.h>
 253               	#elif defined (__AVR_ATmega168P__)
 254               	#  include <avr/iom168p.h>
 255               	#elif defined (__AVR_ATmega169__) || defined (__AVR_ATmega169A__)
 256               	#  include <avr/iom169.h>
 257               	#elif defined (__AVR_ATmega169P__)
 258               	#  include <avr/iom169p.h>
 259               	#elif defined (__AVR_ATmega169PA__)
 260               	#  include <avr/iom169pa.h>
 261               	#elif defined (__AVR_ATmega8HVA__)
 262               	#  include <avr/iom8hva.h>
 263               	#elif defined (__AVR_ATmega16HVA__)
 264               	#  include <avr/iom16hva.h>
 265               	#elif defined (__AVR_ATmega16HVA2__)
 266               	#  include <avr/iom16hva2.h>
 267               	#elif defined (__AVR_ATmega16HVB__)
 268               	#  include <avr/iom16hvb.h>
 269               	#elif defined (__AVR_ATmega8__)
 270               	#  include <avr/iom8.h>
   1               	/* Copyright (c) 2002, Marek Michalkiewicz
 271               	#elif defined (__AVR_ATmega48__) || defined (__AVR_ATmega48A__)
 272               	#  include <avr/iom48.h>
 273               	#elif defined (__AVR_ATmega48P__)
 274               	#  include <avr/iom48p.h>
 275               	#elif defined (__AVR_ATmega88__) || defined (__AVR_ATmega88A__)
 276               	#  include <avr/iom88.h>
 277               	#elif defined (__AVR_ATmega88P__)
 278               	#  include <avr/iom88p.h>
 279               	#elif defined (__AVR_ATmega88PA__)
 280               	#  include <avr/iom88pa.h>
 281               	#elif defined (__AVR_ATmega8515__)
 282               	#  include <avr/iom8515.h>
 283               	#elif defined (__AVR_ATmega8535__)
 284               	#  include <avr/iom8535.h>
 285               	#elif defined (__AVR_AT90S8535__)
 286               	#  include <avr/io8535.h>
 287               	#elif defined (__AVR_AT90C8534__)
 288               	#  include <avr/io8534.h>
 289               	#elif defined (__AVR_AT90S8515__)
 290               	#  include <avr/io8515.h>
 291               	#elif defined (__AVR_AT90S4434__)
 292               	#  include <avr/io4434.h>
 293               	#elif defined (__AVR_AT90S4433__)
 294               	#  include <avr/io4433.h>
 295               	#elif defined (__AVR_AT90S4414__)
 296               	#  include <avr/io4414.h>
 297               	#elif defined (__AVR_ATtiny22__)
 298               	#  include <avr/iotn22.h>
 299               	#elif defined (__AVR_ATtiny26__)
 300               	#  include <avr/iotn26.h>
 301               	#elif defined (__AVR_AT90S2343__)
 302               	#  include <avr/io2343.h>
 303               	#elif defined (__AVR_AT90S2333__)
 304               	#  include <avr/io2333.h>
 305               	#elif defined (__AVR_AT90S2323__)
 306               	#  include <avr/io2323.h>
 307               	#elif defined (__AVR_AT90S2313__)
 308               	#  include <avr/io2313.h>
 309               	#elif defined (__AVR_ATtiny2313__)
 310               	#  include <avr/iotn2313.h>
 311               	#elif defined (__AVR_ATtiny2313A__)
 312               	#  include <avr/iotn2313a.h>
 313               	#elif defined (__AVR_ATtiny13__)
 314               	#  include <avr/iotn13.h>
 315               	#elif defined (__AVR_ATtiny13A__)
 316               	#  include <avr/iotn13a.h>
 317               	#elif defined (__AVR_ATtiny25__)
 318               	#  include <avr/iotn25.h>
 319               	#elif defined (__AVR_ATtiny4313__)
 320               	#  include <avr/iotn4313.h>
 321               	#elif defined (__AVR_ATtiny45__)
 322               	#  include <avr/iotn45.h>
 323               	#elif defined (__AVR_ATtiny85__)
 324               	#  include <avr/iotn85.h>
 325               	#elif defined (__AVR_ATtiny24__)
 326               	#  include <avr/iotn24.h>
 327               	#elif defined (__AVR_ATtiny24A__)
 328               	#  include <avr/iotn24a.h>
 329               	#elif defined (__AVR_ATtiny44__)
 330               	#  include <avr/iotn44.h>
 331               	#elif defined (__AVR_ATtiny44A__)
 332               	#  include <avr/iotn44a.h>
 333               	#elif defined (__AVR_ATtiny84__)
 334               	#  include <avr/iotn84.h>
 335               	#elif defined (__AVR_ATtiny261__)
 336               	#  include <avr/iotn261.h>
 337               	#elif defined (__AVR_ATtiny261A__)
 338               	#  include <avr/iotn261a.h>
 339               	#elif defined (__AVR_ATtiny461__)
 340               	#  include <avr/iotn461.h>
 341               	#elif defined (__AVR_ATtiny461A__)
 342               	#  include <avr/iotn461a.h>
 343               	#elif defined (__AVR_ATtiny861__)
 344               	#  include <avr/iotn861.h>
 345               	#elif defined (__AVR_ATtiny861A__)
 346               	#  include <avr/iotn861a.h>
 347               	#elif defined (__AVR_ATtiny43U__)
 348               	#  include <avr/iotn43u.h>
 349               	#elif defined (__AVR_ATtiny48__)
 350               	#  include <avr/iotn48.h>
 351               	#elif defined (__AVR_ATtiny88__)
 352               	#  include <avr/iotn88.h>
 353               	#elif defined (__AVR_ATtiny87__)
 354               	#  include <avr/iotn87.h>
 355               	#elif defined (__AVR_ATtiny167__)
 356               	#  include <avr/iotn167.h>
 357               	#elif defined (__AVR_AT90SCR100__)
 358               	#  include <avr/io90scr100.h>
 359               	#elif defined (__AVR_ATxmega16A4__)
 360               	#  include <avr/iox16a4.h>
 361               	#elif defined (__AVR_ATxmega16D4__)
 362               	#  include <avr/iox16d4.h>
 363               	#elif defined (__AVR_ATxmega32A4__)
 364               	#  include <avr/iox32a4.h>
 365               	#elif defined (__AVR_ATxmega32D4__)
 366               	#  include <avr/iox32d4.h>
 367               	#elif defined (__AVR_ATxmega64A1__)
 368               	#  include <avr/iox64a1.h>
 369               	#elif defined (__AVR_ATxmega64A3__)
 370               	#  include <avr/iox64a3.h>
 371               	#elif defined (__AVR_ATxmega64D3__)
 372               	#  include <avr/iox64d3.h>
 373               	#elif defined (__AVR_ATxmega128A1__)
 374               	#  include <avr/iox128a1.h>
 375               	#elif defined (__AVR_ATxmega128A3__)
 376               	#  include <avr/iox128a3.h>
 377               	#elif defined (__AVR_ATxmega128D3__)
 378               	#  include <avr/iox128d3.h>
 379               	#elif defined (__AVR_ATxmega192A3__)
 380               	#  include <avr/iox192a3.h>
 381               	#elif defined (__AVR_ATxmega192D3__)
 382               	#  include <avr/iox192d3.h>
 383               	#elif defined (__AVR_ATxmega256A3__)
 384               	#  include <avr/iox256a3.h>
 385               	#elif defined (__AVR_ATxmega256A3B__)
 386               	#  include <avr/iox256a3b.h>
 387               	#elif defined (__AVR_ATxmega256D3__)
 388               	#  include <avr/iox256d3.h>
 389               	#elif defined (__AVR_ATA6289__)
 390               	#  include <avr/ioa6289.h>
 391               	/* avr1: the following only supported for assembler programs */
 392               	#elif defined (__AVR_ATtiny28__)
 393               	#  include <avr/iotn28.h>
 394               	#elif defined (__AVR_AT90S1200__)
 395               	#  include <avr/io1200.h>
 396               	#elif defined (__AVR_ATtiny15__)
 397               	#  include <avr/iotn15.h>
 398               	#elif defined (__AVR_ATtiny12__)
 399               	#  include <avr/iotn12.h>
 400               	#elif defined (__AVR_ATtiny11__)
 401               	#  include <avr/iotn11.h>
 402               	#else
 403               	#  if !defined(__COMPILING_AVR_LIBC__)
 404               	#    warning "device type not defined"
 405               	#  endif
 406               	#endif
 407               	
 408               	#include <avr/portpins.h>
   1               	/* Copyright (c) 2003  Theodore A. Roth
 409               	
 410               	#include <avr/common.h>
   1               	/* Copyright (c) 2007 Eric B. Weddington
 411               	
 412               	#include <avr/version.h>
   1               	/* Copyright (c) 2005, Joerg Wunsch                               -*- c -*-
 413               	
 414               	/* Include fuse.h after individual IO header files. */
 415               	#include <avr/fuse.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 416               	
 417               	/* Include lock.h after individual IO header files. */
 418               	#include <avr/lock.h>
   1               	/* Copyright (c) 2007, Atmel Corporation
 419               	
  24               	efine macro    .macro  /* GNU Assembler macro definition */
  25               	#   define endm     .endm   /* End of GNU Assembler macro definition */
  26               	#endif  /* __IAR_SYSTEMS_ASM__ */
  27               	#include "usbdrv.h" /* for common defs */
   1               	/* Name: usbdrv.h
   2               	 * Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2004-12-29
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id: usbdrv.h 536 2008-02-28 21:11:35Z cs $
   9               	 */
  10               	
  11               	#ifndef __usbdrv_h_included__
  12               	#define __usbdrv_h_included__
  13               	#include "usbconfig.h"
   1               	/* Name: usbconfig.h
  14               	compat.h"
  28               	register names */
  29               	#define x1      r16
  30               	#define x2      r17
  31               	#define shift   r18
  32               	#define cnt     r19
  33               	#define x3      r20
  34               	#define x4      r21
  35               	#define bitcnt  r22
  36               	#define phase   x4
  37               	#define leap    x4
  38               	
  39               	/* Some assembler dependent definitions and declarations: */
  40               	
  41               	#ifdef __IAR_SYSTEMS_ASM__
  42               	
  43               	#   define nop2     rjmp    $+2 /* jump to next instruction */
  44               	#   define XL       r26
  45               	#   define XH       r27
  46               	#   define YL       r28
  47               	#   define YH       r29
  48               	#   define ZL       r30
  49               	#   define ZH       r31
  50               	#   define lo8(x)   LOW(x)
  51               	#   define hi8(x)   (((x)>>8) & 0xff)   /* not HIGH to allow XLINK to make a proper range check */
  52               	
  53               	    extern  usbRxBuf, usbDeviceAddr, usbNewDeviceAddr, usbInputBufOffset
  54               	    extern  usbCurrentTok, usbRxLen, usbRxToken, usbTxLen
  55               	    extern  usbTxBuf, usbMsgLen, usbTxLen1, usbTxBuf1, usbTxLen3, usbTxBuf3
  56               	#   if USB_COUNT_SOF
  57               	        extern usbSofCount
  58               	#   endif
  59               	    public  usbCrc16
  60               	    public  usbCrc16Append
  61               	
  62               	    COMMON  INTVEC
  63               	#   ifndef USB_INTR_VECTOR
  64               	        ORG     INT0_vect
  65               	#   else /* USB_INTR_VECTOR */
  66               	        ORG     USB_INTR_VECTOR
  67               	#       undef   USB_INTR_VECTOR
  68               	#   endif /* USB_INTR_VECTOR */
  69               	#   define  USB_INTR_VECTOR usbInterruptHandler
  70               	    rjmp    USB_INTR_VECTOR
  71               	    RSEG    CODE
  72               	
  73               	#else /* __IAR_SYSTEMS_ASM__ */
  74               	
  75               	#   define nop2     rjmp    .+0 /* jump to next instruction */
  76               	
  77               	#   ifndef USB_INTR_VECTOR /* default to hardware interrupt INT0 */
  78               	#       define USB_INTR_VECTOR  SIG_INTERRUPT0
  79               	#   endif
  80               	    .text
  81               	    .global USB_INTR_VECTOR
  83               	    .global usbCrc16
  84               	    .global usbCrc16Append
  85               	#endif /* __IAR_SYSTEMS_ASM__ */
  86               	
  87               	
  88               	#if USB_INTR_PENDING < 0x40 /* This is an I/O address, use in and out */
  89               	#   define  USB_LOAD_PENDING(reg)   in reg, USB_INTR_PENDING
  90               	#   define  USB_STORE_PENDING(reg)  out USB_INTR_PENDING, reg
  91               	#else   /* It's a memory address, use lds and sts */
  92               	#   define  USB_LOAD_PENDING(reg)   lds reg, USB_INTR_PENDING
  93               	#   define  USB_STORE_PENDING(reg)  sts USB_INTR_PENDING, reg
  94               	#endif
  95               	
  96               	
  97               	;----------------------------------------------------------------------------
  98               	; Utility functions
  99               	;----------------------------------------------------------------------------
 100               	
 101               	#ifdef __IAR_SYSTEMS_ASM__
 102               	/* Register assignments for usbCrc16 on IAR cc */
 103               	/* Calling conventions on IAR:
 104               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
 105               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
 106               	 * Result is passed in r16/r17
 107               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
 108               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
 109               	 */
 110               	RTMODEL "__rt_version", "3"
 111               	/* The line above will generate an error if cc calling conventions change.
 112               	 * The value "3" above is valid for IAR 4.10B/W32
 113               	 */
 114               	#   define argLen   r18 /* argument 2 */
 115               	#   define argPtrL  r16 /* argument 1 */
 116               	#   define argPtrH  r17 /* argument 1 */
 117               	
 118               	#   define resCrcL  r16 /* result */
 119               	#   define resCrcH  r17 /* result */
 120               	
 121               	#   define ptrL     ZL
 122               	#   define ptrH     ZH
 123               	#   define ptr      Z
 124               	#   define byte     r22
 125               	#   define bitCnt   r19
 126               	#   define polyL    r20
 127               	#   define polyH    r21
 128               	#   define scratch  r23
 129               	
 130               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 131               	/* Register assignments for usbCrc16 on gcc */
 132               	/* Calling conventions on gcc:
 133               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 134               	 * Callee must preserve r1-r17, r28/r29
 135               	 * Result is passed in r24/r25
 136               	 */
 137               	#   define argLen   r22 /* argument 2 */
 138               	#   define argPtrL  r24 /* argument 1 */
 139               	#   define argPtrH  r25 /* argument 1 */
 140               	
 141               	#   define resCrcL  r24 /* result */
 142               	#   define resCrcH  r25 /* result */
 143               	
 144               	#   define ptrL     XL
 145               	#   define ptrH     XH
 146               	#   define ptr      x
 147               	#   define byte     r18
 148               	#   define bitCnt   r19
 149               	#   define polyL    r20
 150               	#   define polyH    r21
 151               	#   define scratch  r23
 152               	
 153               	#endif
 154               	
 155               	; extern unsigned usbCrc16(unsigned char *data, unsigned char len);
 156               	; data: r24/25
 157               	; len: r22
 158               	; temp variables:
 159               	;   r18: data byte
 160               	;   r19: bit counter
 161               	;   r20/21: polynomial
 162               	;   r23: scratch
 163               	;   r24/25: crc-sum
 164               	;   r26/27=X: ptr
 165               	usbCrc16:
 166               	    mov     ptrL, argPtrL
 167:usbdrv/usbdrvasm.S ****     mov     ptrH, argPtrH
 168:usbdrv/usbdrvasm.S ****     ldi     resCrcL, 0
 169:usbdrv/usbdrvasm.S ****     ldi     resCrcH, 0
 170:usbdrv/usbdrvasm.S ****     ldi     polyL, lo8(0xa001)
 171:usbdrv/usbdrvasm.S ****     ldi     polyH, hi8(0xa001)
 172:usbdrv/usbdrvasm.S ****     com     argLen      ; argLen = -argLen - 1
 173:usbdrv/usbdrvasm.S **** crcByteLoop:
 174               	    subi    argLen, -1
 175:usbdrv/usbdrvasm.S ****     brcc    crcReady    ; modified loop to ensure that carry is set below
 176:usbdrv/usbdrvasm.S ****     ld      byte, ptr+
 177:usbdrv/usbdrvasm.S ****     ldi     bitCnt, -8  ; strange loop counter to ensure that carry is set where we need it
 178:usbdrv/usbdrvasm.S ****     eor     resCrcL, byte
 179:usbdrv/usbdrvasm.S **** crcBitLoop:
 180               	    ror     resCrcH     ; carry is always set here
 181:usbdrv/usbdrvasm.S ****     ror     resCrcL
 182:usbdrv/usbdrvasm.S ****     brcs    crcNoXor
 183:usbdrv/usbdrvasm.S ****     eor     resCrcL, polyL
 184:usbdrv/usbdrvasm.S ****     eor     resCrcH, polyH
 185:usbdrv/usbdrvasm.S **** crcNoXor:
 186               	    subi    bitCnt, -1
 187:usbdrv/usbdrvasm.S ****     brcs    crcBitLoop
 188:usbdrv/usbdrvasm.S ****     rjmp    crcByteLoop
 189:usbdrv/usbdrvasm.S **** crcReady:
 190               	    ret
 191:usbdrv/usbdrvasm.S **** ; Thanks to Reimar Doeffinger for optimizing this CRC routine!
 192               	
 193               	; extern unsigned usbCrc16Append(unsigned char *data, unsigned char len);
 194               	usbCrc16Append:
 195               	    rcall   usbCrc16
 196:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcL
 197:usbdrv/usbdrvasm.S ****     st      ptr+, resCrcH
 198:usbdrv/usbdrvasm.S ****     ret
 199:usbdrv/usbdrvasm.S **** 
 200               	#undef argLen
 201               	#undef argPtrL
 202               	#undef argPtrH
 203               	#undef resCrcL
 204               	#undef resCrcH
 205               	#undef ptrL
 206               	#undef ptrH
 207               	#undef ptr
 208               	#undef byte
 209               	#undef bitCnt
 210               	#undef polyL
 211               	#undef polyH
 212               	#undef scratch
 213               	
 214               	
 215               	#if USB_CFG_HAVE_MEASURE_FRAME_LENGTH
 216               	#ifdef __IAR_SYSTEMS_ASM__
 217               	/* Register assignments for usbMeasureFrameLength on IAR cc */
 218               	/* Calling conventions on IAR:
 219               	 * First parameter passed in r16/r17, second in r18/r19 and so on.
 220               	 * Callee must preserve r4-r15, r24-r29 (r28/r29 is frame pointer)
 221               	 * Result is passed in r16/r17
 222               	 * In case of the "tiny" memory model, pointers are only 8 bit with no
 223               	 * padding. We therefore pass argument 1 as "16 bit unsigned".
 224               	 */
 225               	#   define resL     r16
 226               	#   define resH     r17
 227               	#   define cnt16L   r30
 228               	#   define cnt16H   r31
 229               	#   define cntH     r18
 230               	
 231               	#else  /* __IAR_SYSTEMS_ASM__ */ 
 232               	/* Register assignments for usbMeasureFrameLength on gcc */
 233               	/* Calling conventions on gcc:
 234               	 * First parameter passed in r24/r25, second in r22/23 and so on.
 235               	 * Callee must preserve r1-r17, r28/r29
 236               	 * Result is passed in r24/r25
 237               	 */
 238               	#   define resL     r24
 239               	#   define resH     r25
 240               	#   define cnt16L   r24
 241               	#   define cnt16H   r25
 242               	#   define cntH     r26
 243               	#endif
 244               	#   define cnt16    cnt16L
 245               	
 246               	; extern unsigned usbMeasurePacketLength(void);
 247               	; returns time between two idle strobes in multiples of 7 CPU clocks
 248               	.global usbMeasureFrameLength
 249               	usbMeasureFrameLength:
 250               	    ldi     cntH, 6         ; wait ~ 10 ms for D- == 0
 251               	    clr     cnt16L
 252               	    clr     cnt16H
 253               	usbMFTime16:
 254               	    dec     cntH
 255               	    breq    usbMFTimeout
 256               	usbMFWaitStrobe:            ; first wait for D- == 0 (idle strobe)
 257               	    sbiw    cnt16, 1        ;[0] [6]
 258               	    breq    usbMFTime16     ;[2]
 259               	    sbic    USBIN, USBMINUS ;[3]
 260               	    rjmp    usbMFWaitStrobe ;[4]
 261               	usbMFWaitIdle:              ; then wait until idle again
 262               	    sbis    USBIN, USBMINUS ;1 wait for D- == 1
 263               	    rjmp    usbMFWaitIdle   ;2
 264               	    ldi     cnt16L, 1       ;1 represents cycles so far
 265               	    clr     cnt16H          ;1
 266               	usbMFWaitLoop:
 267               	    in      cntH, USBIN     ;[0] [7]
 268               	    adiw    cnt16, 1        ;[1]
 269               	    breq    usbMFTimeout    ;[3]
 270               	    andi    cntH, USBMASK   ;[4]
 271               	    brne    usbMFWaitLoop   ;[5]
 272               	usbMFTimeout:
 273               	#if resL != cnt16L
 274               	    mov     resL, cnt16L
 275               	    mov     resH, cnt16H
 276               	#endif
 277               	    ret
 278               	
 279               	#undef resL
 280               	#undef resH
 281               	#undef cnt16
 282               	#undef cnt16L
 283               	#undef cnt16H
 284               	#undef cntH
 285               	
 286               	#endif  /* USB_CFG_HAVE_MEASURE_FRAME_LENGTH */
 287               	
 288               	;----------------------------------------------------------------------------
 289               	; Now include the clock rate specific code
 290               	;----------------------------------------------------------------------------
 291               	
 292               	#ifndef USB_CFG_CLOCK_KHZ
 293               	#   define USB_CFG_CLOCK_KHZ 12000
 294               	#endif
 295               	
 296               	#if USB_CFG_CLOCK_KHZ == 12000
 297               	#   include "usbdrvasm12.inc"
 298               	#elif USB_CFG_CLOCK_KHZ == 15000
   1               	/* Name: usbdrvasm12.inc
   2               	 * Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2004-12-29
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * This Revision: $Id: usbdrvasm12.inc 483 2008-02-05 15:05:32Z cs $
   9               	 */
  10               	
  11               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  12               	 * appropriate implementation!
  13               	 */
  14               	
  15               	/*
  16               	General Description:
  17               	This file is the 12 MHz version of the asssembler part of the USB driver. It
  18               	requires a 12 MHz crystal (not a ceramic resonator and not a calibrated RC
  19               	oscillator).
  20               	
  21               	See usbdrv.h for a description of the entire driver.
  22               	
  23               	Since almost all of this code is timing critical, don't change unless you
  24               	really know what you are doing! Many parts require not only a maximum number
  25               	of CPU cycles, but even an exact number of cycles!
  26               	
  27               	
  28               	Timing constraints according to spec (in bit times):
  29               	timing subject                                      min max    CPUcycles
  30               	---------------------------------------------------------------------------
  31               	EOP of OUT/SETUP to sync pattern of DATA0 (both rx) 2   16     16-128
  32               	EOP of IN to sync pattern of DATA0 (rx, then tx)    2   7.5    16-60
  33               	DATAx (rx) to ACK/NAK/STALL (tx)                    2   7.5    16-60
  34               	*/
  35               	
  36               	;Software-receiver engine. Strict timing! Don't change unless you can preserve timing!
  37               	;interrupt response time: 4 cycles + insn running = 7 max if interrupts always enabled
  38               	;max allowable interrupt latency: 34 cycles -> max 25 cycles interrupt disable
  39               	;max stack usage: [ret(2), YL, SREG, YH, shift, x1, x2, x3, cnt, x4] = 11 bytes
  40               	;Numbers in brackets are maximum cycles since SOF.
  41               	USB_INTR_VECTOR:
  42               	;order of registers pushed: YL, SREG [sofError], YH, shift, x1, x2, x3, cnt
  43:usbdrv/usbdrvasm12.inc ****     push    YL              ;2 [35] push only what is necessary to sync with edge ASAP
  44:usbdrv/usbdrvasm12.inc ****     in      YL, SREG        ;1 [37]
  45:usbdrv/usbdrvasm12.inc ****     push    YL              ;2 [39]
  46               	;----------------------------------------------------------------------------
  47               	; Synchronize with sync pattern:
  48               	;----------------------------------------------------------------------------
  49               	;sync byte (D-) pattern LSb to MSb: 01010100 [1 = idle = J, 0 = K]
  50               	;sync up with J to K edge during sync pattern -- use fastest possible loops
  51               	;first part has no timeout because it waits for IDLE or SE1 (== disconnected)
  52               	waitForJ:
  53:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS ;1 [40] wait for D- == 1
  54:usbdrv/usbdrvasm12.inc ****     rjmp    waitForJ        ;2
  55               	waitForK:
  56               	;The following code results in a sampling window of 1/4 bit which meets the spec.
  57:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS
  58:usbdrv/usbdrvasm12.inc ****     rjmp    foundK
  59:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS
  60:usbdrv/usbdrvasm12.inc ****     rjmp    foundK
  61:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS
  62:usbdrv/usbdrvasm12.inc ****     rjmp    foundK
  63:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS
  64:usbdrv/usbdrvasm12.inc ****     rjmp    foundK
  65:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS
  66:usbdrv/usbdrvasm12.inc ****     rjmp    foundK
  67               	#if USB_COUNT_SOF
  68               	    lds     YL, usbSofCount
  69               	    inc     YL
  70               	    sts     usbSofCount, YL
  71               	#endif  /* USB_COUNT_SOF */
  72:usbdrv/usbdrvasm12.inc ****     rjmp    sofError
  73               	foundK:
  74               	;{3, 5} after falling D- edge, average delay: 4 cycles [we want 4 for center sampling]
  75               	;we have 1 bit time for setup purposes, then sample again. Numbers in brackets
  76               	;are cycles from center of first sync (double K) bit after the instruction
  77:usbdrv/usbdrvasm12.inc ****     push    YH                  ;2 [2]
  78:usbdrv/usbdrvasm12.inc ****     lds     YL, usbInputBufOffset;2 [4]
  79:usbdrv/usbdrvasm12.inc ****     clr     YH                  ;1 [5]
  80:usbdrv/usbdrvasm12.inc ****     subi    YL, lo8(-(usbRxBuf));1 [6]
  81:usbdrv/usbdrvasm12.inc ****     sbci    YH, hi8(-(usbRxBuf));1 [7]
  82               	
  83:usbdrv/usbdrvasm12.inc ****     sbis    USBIN, USBMINUS ;1 [8] we want two bits K [sample 1 cycle too early]
  84:usbdrv/usbdrvasm12.inc ****     rjmp    haveTwoBitsK    ;2 [10]
  85:usbdrv/usbdrvasm12.inc ****     pop     YH              ;2 [11] undo the push from before
  86:usbdrv/usbdrvasm12.inc ****     rjmp    waitForK        ;2 [13] this was not the end of sync, retry
  87               	haveTwoBitsK:
  88               	;----------------------------------------------------------------------------
  89               	; push more registers and initialize values while we sample the first bits:
  90               	;----------------------------------------------------------------------------
  91:usbdrv/usbdrvasm12.inc ****     push    shift           ;2 [16]
  92:usbdrv/usbdrvasm12.inc ****     push    x1              ;2 [12]
  93:usbdrv/usbdrvasm12.inc ****     push    x2              ;2 [14]
  94               	
  95:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN       ;1 [17] <-- sample bit 0
  96:usbdrv/usbdrvasm12.inc ****     ldi     shift, 0xff     ;1 [18]
  97:usbdrv/usbdrvasm12.inc ****     bst     x1, USBMINUS    ;1 [19]
  98:usbdrv/usbdrvasm12.inc ****     bld     shift, 0        ;1 [20]
  99:usbdrv/usbdrvasm12.inc ****     push    x3              ;2 [22]
 100:usbdrv/usbdrvasm12.inc ****     push    cnt             ;2 [24]
 101               	    
 102:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN       ;1 [25] <-- sample bit 1
 103:usbdrv/usbdrvasm12.inc ****     ser     x3              ;1 [26] [inserted init instruction]
 104:usbdrv/usbdrvasm12.inc ****     eor     x1, x2          ;1 [27]
 105:usbdrv/usbdrvasm12.inc ****     bst     x1, USBMINUS    ;1 [28]
 106:usbdrv/usbdrvasm12.inc ****     bld     shift, 1        ;1 [29]
 107:usbdrv/usbdrvasm12.inc ****     ldi     cnt, USB_BUFSIZE;1 [30] [inserted init instruction]
 108:usbdrv/usbdrvasm12.inc ****     rjmp    rxbit2          ;2 [32]
 109               	
 110               	;----------------------------------------------------------------------------
 111               	; Receiver loop (numbers in brackets are cycles within byte after instr)
 112               	;----------------------------------------------------------------------------
 113               	
 114               	unstuff0:               ;1 (branch taken)
 115:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x01   ;1 [15]
 116:usbdrv/usbdrvasm12.inc ****     mov     x1, x2      ;1 [16] x2 contains last sampled (stuffed) bit
 117:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [17] <-- sample bit 1 again
 118:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x01 ;1 [18]
 119:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff0 ;2 [20]
 120               	
 121               	unstuff1:               ;1 (branch taken)
 122:usbdrv/usbdrvasm12.inc ****     mov     x2, x1      ;1 [21] x1 contains last sampled (stuffed) bit
 123:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x02   ;1 [22]
 124:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x02 ;1 [23]
 125:usbdrv/usbdrvasm12.inc ****     nop                 ;1 [24]
 126:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [25] <-- sample bit 2 again
 127:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff1 ;2 [27]
 128               	
 129               	unstuff2:               ;1 (branch taken)
 130:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x04   ;1 [29]
 131:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x04 ;1 [30]
 132:usbdrv/usbdrvasm12.inc ****     mov     x1, x2      ;1 [31] x2 contains last sampled (stuffed) bit
 133:usbdrv/usbdrvasm12.inc ****     nop                 ;1 [32]
 134:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [33] <-- sample bit 3
 135:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff2 ;2 [35]
 136               	
 137               	unstuff3:               ;1 (branch taken)
 138:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [34] <-- sample stuffed bit 3 [one cycle too late]
 139:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x08   ;1 [35]
 140:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x08 ;1 [36]
 141:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff3 ;2 [38]
 142               	
 143               	unstuff4:               ;1 (branch taken)
 144:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x10   ;1 [40]
 145:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [41] <-- sample stuffed bit 4
 146:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x10 ;1 [42]
 147:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff4 ;2 [44]
 148               	
 149               	unstuff5:               ;1 (branch taken)
 150:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x20   ;1 [48]
 151:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [49] <-- sample stuffed bit 5
 152:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x20 ;1 [50]
 153:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff5 ;2 [52]
 154               	
 155               	unstuff6:               ;1 (branch taken)
 156:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x40   ;1 [56]
 157:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [57] <-- sample stuffed bit 6
 158:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x40 ;1 [58]
 159:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff6 ;2 [60]
 160               	
 161               	; extra jobs done during bit interval:
 162               	; bit 0:    store, clear [SE0 is unreliable here due to bit dribbling in hubs]
 163               	; bit 1:    se0 check
 164               	; bit 2:    overflow check
 165               	; bit 3:    recovery from delay [bit 0 tasks took too long]
 166               	; bit 4:    none
 167               	; bit 5:    none
 168               	; bit 6:    none
 169               	; bit 7:    jump, eor
 170               	rxLoop:
 171:usbdrv/usbdrvasm12.inc ****     eor     x3, shift   ;1 [0] reconstruct: x3 is 0 at bit locations we changed, 1 at others
 172:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [1] <-- sample bit 0
 173:usbdrv/usbdrvasm12.inc ****     st      y+, x3      ;2 [3] store data
 174:usbdrv/usbdrvasm12.inc ****     ser     x3          ;1 [4]
 175:usbdrv/usbdrvasm12.inc ****     nop                 ;1 [5]
 176:usbdrv/usbdrvasm12.inc ****     eor     x2, x1      ;1 [6]
 177:usbdrv/usbdrvasm12.inc ****     bst     x2, USBMINUS;1 [7]
 178:usbdrv/usbdrvasm12.inc ****     bld     shift, 0    ;1 [8]
 179:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [9] <-- sample bit 1 (or possibly bit 0 stuffed)
 180:usbdrv/usbdrvasm12.inc ****     andi    x2, USBMASK ;1 [10]
 181:usbdrv/usbdrvasm12.inc ****     breq    se0         ;1 [11] SE0 check for bit 1
 182:usbdrv/usbdrvasm12.inc ****     andi    shift, 0xf9 ;1 [12]
 183               	didUnstuff0:
 184:usbdrv/usbdrvasm12.inc ****     breq    unstuff0    ;1 [13]
 185:usbdrv/usbdrvasm12.inc ****     eor     x1, x2      ;1 [14]
 186:usbdrv/usbdrvasm12.inc ****     bst     x1, USBMINUS;1 [15]
 187:usbdrv/usbdrvasm12.inc ****     bld     shift, 1    ;1 [16]
 188               	rxbit2:
 189:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [17] <-- sample bit 2 (or possibly bit 1 stuffed)
 190:usbdrv/usbdrvasm12.inc ****     andi    shift, 0xf3 ;1 [18]
 191:usbdrv/usbdrvasm12.inc ****     breq    unstuff1    ;1 [19] do remaining work for bit 1
 192               	didUnstuff1:
 193:usbdrv/usbdrvasm12.inc ****     subi    cnt, 1      ;1 [20]
 194:usbdrv/usbdrvasm12.inc ****     brcs    overflow    ;1 [21] loop control
 195:usbdrv/usbdrvasm12.inc ****     eor     x2, x1      ;1 [22]
 196:usbdrv/usbdrvasm12.inc ****     bst     x2, USBMINUS;1 [23]
 197:usbdrv/usbdrvasm12.inc ****     bld     shift, 2    ;1 [24]
 198:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [25] <-- sample bit 3 (or possibly bit 2 stuffed)
 199:usbdrv/usbdrvasm12.inc ****     andi    shift, 0xe7 ;1 [26]
 200:usbdrv/usbdrvasm12.inc ****     breq    unstuff2    ;1 [27]
 201               	didUnstuff2:
 202:usbdrv/usbdrvasm12.inc ****     eor     x1, x2      ;1 [28]
 203:usbdrv/usbdrvasm12.inc ****     bst     x1, USBMINUS;1 [29]
 204:usbdrv/usbdrvasm12.inc ****     bld     shift, 3    ;1 [30]
 205               	didUnstuff3:
 206:usbdrv/usbdrvasm12.inc ****     andi    shift, 0xcf ;1 [31]
 207:usbdrv/usbdrvasm12.inc ****     breq    unstuff3    ;1 [32]
 208:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [33] <-- sample bit 4
 209:usbdrv/usbdrvasm12.inc ****     eor     x2, x1      ;1 [34]
 210:usbdrv/usbdrvasm12.inc ****     bst     x2, USBMINUS;1 [35]
 211:usbdrv/usbdrvasm12.inc ****     bld     shift, 4    ;1 [36]
 212               	didUnstuff4:
 213:usbdrv/usbdrvasm12.inc ****     andi    shift, 0x9f ;1 [37]
 214:usbdrv/usbdrvasm12.inc ****     breq    unstuff4    ;1 [38]
 215:usbdrv/usbdrvasm12.inc ****     nop2                ;2 [40]
 216:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [41] <-- sample bit 5
 217:usbdrv/usbdrvasm12.inc ****     eor     x1, x2      ;1 [42]
 218:usbdrv/usbdrvasm12.inc ****     bst     x1, USBMINUS;1 [43]
 219:usbdrv/usbdrvasm12.inc ****     bld     shift, 5    ;1 [44]
 220               	didUnstuff5:
 221:usbdrv/usbdrvasm12.inc ****     andi    shift, 0x3f ;1 [45]
 222:usbdrv/usbdrvasm12.inc ****     breq    unstuff5    ;1 [46]
 223:usbdrv/usbdrvasm12.inc ****     nop2                ;2 [48]
 224:usbdrv/usbdrvasm12.inc ****     in      x1, USBIN   ;1 [49] <-- sample bit 6
 225:usbdrv/usbdrvasm12.inc ****     eor     x2, x1      ;1 [50]
 226:usbdrv/usbdrvasm12.inc ****     bst     x2, USBMINUS;1 [51]
 227:usbdrv/usbdrvasm12.inc ****     bld     shift, 6    ;1 [52]
 228               	didUnstuff6:
 229:usbdrv/usbdrvasm12.inc ****     cpi     shift, 0x02 ;1 [53]
 230:usbdrv/usbdrvasm12.inc ****     brlo    unstuff6    ;1 [54]
 231:usbdrv/usbdrvasm12.inc ****     nop2                ;2 [56]
 232:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [57] <-- sample bit 7
 233:usbdrv/usbdrvasm12.inc ****     eor     x1, x2      ;1 [58]
 234:usbdrv/usbdrvasm12.inc ****     bst     x1, USBMINUS;1 [59]
 235:usbdrv/usbdrvasm12.inc ****     bld     shift, 7    ;1 [60]
 236               	didUnstuff7:
 237:usbdrv/usbdrvasm12.inc ****     cpi     shift, 0x04 ;1 [61]
 238:usbdrv/usbdrvasm12.inc ****     brsh    rxLoop      ;2 [63] loop control
 239               	unstuff7:
 240:usbdrv/usbdrvasm12.inc ****     andi    x3, ~0x80   ;1 [63]
 241:usbdrv/usbdrvasm12.inc ****     ori     shift, 0x80 ;1 [64]
 242:usbdrv/usbdrvasm12.inc ****     in      x2, USBIN   ;1 [65] <-- sample stuffed bit 7
 243:usbdrv/usbdrvasm12.inc ****     nop                 ;1 [66]
 244:usbdrv/usbdrvasm12.inc ****     rjmp    didUnstuff7 ;2 [68]
 245               	
 246               	macro POP_STANDARD ; 12 cycles
 247               	    pop     cnt
 248               	    pop     x3
 249               	    pop     x2
 250               	    pop     x1
 251               	    pop     shift
 252               	    pop     YH
 253               	endm
 254               	macro POP_RETI     ; 5 cycles
 255               	    pop     YL
 256               	    out     SREG, YL
 257               	    pop     YL
 258               	endm
 259               	
 260               	#include "asmcommon.inc"
   1               	/* Name: asmcommon.inc
   2               	 * Project: AVR USB driver
   3               	 * Author: Christian Starkjohann
   4               	 * Creation Date: 2007-11-05
   5               	 * Tabsize: 4
   6               	 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
   7               	 * License: GNU GPL v2 (see License.txt) or proprietary (CommercialLicense.txt)
   8               	 * Revision: $Id$
   9               	 */
  10               	
  11               	/* Do not link this file! Link usbdrvasm.S instead, which includes the
  12               	 * appropriate implementation!
  13               	 */
  14               	
  15               	/*
  16               	General Description:
  17               	This file contains assembler code which is shared among the USB driver
  18               	implementations for different CPU cocks. Since the code must be inserted
  19               	in the middle of the module, it's split out into this file and #included.
  20               	
  21               	Jump destinations called from outside:
  22               	    sofError: Called when no start sequence was found.
  23               	    se0: Called when a package has been successfully received.
  24               	    overflow: Called when receive buffer overflows.
  25               	    doReturn: Called after sending data.
  26               	
  27               	Outside jump destinations used by this module:
  28               	    waitForJ: Called to receive an already arriving packet.
  29               	    sendAckAndReti:
  30               	    sendNakAndReti:
  31               	    sendCntAndReti:
  32               	    usbSendAndReti:
  33               	
  34               	The following macros must be defined before this file is included:
  35               	    .macro POP_STANDARD
  36               	    .endm
  37               	    .macro POP_RETI
  38               	    .endm
  39               	*/
  40               	
  41               	#define token   x1
  42               	
  43               	overflow:
  44:usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT
  45:usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ; clear any pending interrupts
  46               	ignorePacket:
  47:usbdrv/asmcommon.inc ****     clr     token
  48:usbdrv/asmcommon.inc ****     rjmp    storeTokenAndReturn
  49               	
  50               	;----------------------------------------------------------------------------
  51               	; Processing of received packet (numbers in brackets are cycles after center of SE0)
  52               	;----------------------------------------------------------------------------
  53               	;This is the only non-error exit point for the software receiver loop
  54               	;we don't check any CRCs here because there is no time left.
  55               	se0:
  56:usbdrv/asmcommon.inc ****     subi    cnt, USB_BUFSIZE    ;[5]
  57:usbdrv/asmcommon.inc ****     neg     cnt                 ;[6]
  58:usbdrv/asmcommon.inc ****     sub     YL, cnt             ;[7]
  59:usbdrv/asmcommon.inc ****     sbci    YH, 0               ;[8]
  60:usbdrv/asmcommon.inc ****     ldi     x2, 1<<USB_INTR_PENDING_BIT ;[9]
  61:usbdrv/asmcommon.inc ****     USB_STORE_PENDING(x2)       ;[10] clear pending intr and check flag later. SE0 should be over.
  62:usbdrv/asmcommon.inc ****     ld      token, y            ;[11]
  63:usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA0 ;[13]
  64:usbdrv/asmcommon.inc ****     breq    handleData          ;[14]
  65:usbdrv/asmcommon.inc ****     cpi     token, USBPID_DATA1 ;[15]
  66:usbdrv/asmcommon.inc ****     breq    handleData          ;[16]
  67:usbdrv/asmcommon.inc ****     lds     shift, usbDeviceAddr;[17]
  68:usbdrv/asmcommon.inc ****     ldd     x2, y+1             ;[19] ADDR and 1 bit endpoint number
  69:usbdrv/asmcommon.inc ****     lsl     x2                  ;[21] shift out 1 bit endpoint number
  70:usbdrv/asmcommon.inc ****     cpse    x2, shift           ;[22]
  71:usbdrv/asmcommon.inc ****     rjmp    ignorePacket        ;[23]
  72               	/* only compute endpoint number in x3 if required later */
  73               	#if USB_CFG_HAVE_INTRIN_ENDPOINT || USB_CFG_IMPLEMENT_FN_WRITEOUT
  74:usbdrv/asmcommon.inc ****     ldd     x3, y+2             ;[24] endpoint number + crc
  75:usbdrv/asmcommon.inc ****     rol     x3                  ;[26] shift in LSB of endpoint
  76               	#endif
  77:usbdrv/asmcommon.inc ****     cpi     token, USBPID_IN    ;[27]
  78:usbdrv/asmcommon.inc ****     breq    handleIn            ;[28]
  79:usbdrv/asmcommon.inc ****     cpi     token, USBPID_SETUP ;[29]
  80:usbdrv/asmcommon.inc ****     breq    handleSetupOrOut    ;[30]
  81:usbdrv/asmcommon.inc ****     cpi     token, USBPID_OUT   ;[31]
  82:usbdrv/asmcommon.inc ****     brne    ignorePacket        ;[32] must be ack, nak or whatever
  83               	;   rjmp    handleSetupOrOut    ; fallthrough
  84               	
  85               	;Setup and Out are followed by a data packet two bit times (16 cycles) after
  86               	;the end of SE0. The sync code allows up to 40 cycles delay from the start of
  87               	;the sync pattern until the first bit is sampled. That's a total of 56 cycles.
  88               	handleSetupOrOut:               ;[32]
  89               	#if USB_CFG_IMPLEMENT_FN_WRITEOUT   /* if we have data for endpoint != 0, set usbCurrentTok to addr
  90               	    andi    x3, 0xf             ;[32]
  91               	    breq    storeTokenAndReturn ;[33]
  92               	    mov     token, x3           ;[34] indicate that this is endpoint x OUT
  93               	#endif
  94               	storeTokenAndReturn:
  95:usbdrv/asmcommon.inc ****     sts     usbCurrentTok, token;[35]
  96               	doReturn:
  97:usbdrv/asmcommon.inc ****     POP_STANDARD                ;[37] 12...16 cycles
  98:usbdrv/asmcommon.inc ****     USB_LOAD_PENDING(YL)        ;[49]
  99:usbdrv/asmcommon.inc ****     sbrc    YL, USB_INTR_PENDING_BIT;[50] check whether data is already arriving
 100:usbdrv/asmcommon.inc ****     rjmp    waitForJ            ;[51] save the pops and pushes -- a new interrupt is already pendin
 101               	sofError:
 102:usbdrv/asmcommon.inc ****     POP_RETI                    ;macro call
 103:usbdrv/asmcommon.inc ****     reti
 104               	
 105               	handleData:
 106:usbdrv/asmcommon.inc ****     lds     token, usbCurrentTok;[18]
 107:usbdrv/asmcommon.inc ****     tst     token               ;[20]
 108:usbdrv/asmcommon.inc ****     breq    doReturn            ;[21]
 109:usbdrv/asmcommon.inc ****     lds     x2, usbRxLen        ;[22]
 110:usbdrv/asmcommon.inc ****     tst     x2                  ;[24]
 111:usbdrv/asmcommon.inc ****     brne    sendNakAndReti      ;[25]
 112               	; 2006-03-11: The following two lines fix a problem where the device was not
 113               	; recognized if usbPoll() was called less frequently than once every 4 ms.
 114:usbdrv/asmcommon.inc ****     cpi     cnt, 4              ;[26] zero sized data packets are status phase only -- ignore and a
 115:usbdrv/asmcommon.inc ****     brmi    sendAckAndReti      ;[27] keep rx buffer clean -- we must not NAK next SETUP
 116:usbdrv/asmcommon.inc ****     sts     usbRxLen, cnt       ;[28] store received data, swap buffers
 117:usbdrv/asmcommon.inc ****     sts     usbRxToken, token   ;[30]
 118:usbdrv/asmcommon.inc ****     lds     x2, usbInputBufOffset;[32] swap buffers
 119:usbdrv/asmcommon.inc ****     ldi     cnt, USB_BUFSIZE    ;[34]
 120:usbdrv/asmcommon.inc ****     sub     cnt, x2             ;[35]
 121:usbdrv/asmcommon.inc ****     sts     usbInputBufOffset, cnt;[36] buffers now swapped
 122:usbdrv/asmcommon.inc ****     rjmp    sendAckAndReti      ;[38] 40 + 17 = 57 until SOP
 123               	
 124               	handleIn:
 125               	;We don't send any data as long as the C code has not processed the current
 126               	;input data and potentially updated the output data. That's more efficient
 127               	;in terms of code size than clearing the tx buffers when a packet is received.
 128:usbdrv/asmcommon.inc ****     lds     x1, usbRxLen        ;[30]
 129:usbdrv/asmcommon.inc ****     cpi     x1, 1               ;[32] negative values are flow control, 0 means "buffer free"
 130:usbdrv/asmcommon.inc ****     brge    sendNakAndReti      ;[33] unprocessed input packet?
 131:usbdrv/asmcommon.inc ****     ldi     x1, USBPID_NAK      ;[34] prepare value for usbTxLen
 132               	#if USB_CFG_HAVE_INTRIN_ENDPOINT
 133:usbdrv/asmcommon.inc ****     andi    x3, 0xf             ;[35] x3 contains endpoint
 134:usbdrv/asmcommon.inc ****     brne    handleIn1           ;[36]
 135               	#endif
 136:usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen       ;[37]
 137:usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[39] all handshake tokens have bit 4 set
 138:usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[40] 42 + 16 = 58 until SOP
 139:usbdrv/asmcommon.inc ****     sts     usbTxLen, x1        ;[41] x1 == USBPID_NAK from above
 140:usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf)   ;[43]
 141:usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf)   ;[44]
 142:usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[45] 57 + 12 = 59 until SOP
 143               	
 144               	; Comment about when to set usbTxLen to USBPID_NAK:
 145               	; We should set it back when we receive the ACK from the host. This would
 146               	; be simple to implement: One static variable which stores whether the last
 147               	; tx was for endpoint 0 or 1 and a compare in the receiver to distinguish the
 148               	; ACK. However, we set it back immediately when we send the package,
 149               	; assuming that no error occurs and the host sends an ACK. We save one byte
 150               	; RAM this way and avoid potential problems with endless retries. The rest of
 151               	; the driver assumes error-free transfers anyway.
 152               	
 153               	#if USB_CFG_HAVE_INTRIN_ENDPOINT    /* placed here due to relative jump range */
 154               	handleIn1:                      ;[38]
 155               	#if USB_CFG_HAVE_INTRIN_ENDPOINT3
 156               	; 2006-06-10 as suggested by O.Tamura: support second INTR IN / BULK IN endpoint
 157               	    cpi     x3, USB_CFG_EP3_NUMBER;[38]
 158               	    breq    handleIn3           ;[39]
 159               	#endif
 160:usbdrv/asmcommon.inc ****     lds     cnt, usbTxLen1      ;[40]
 161:usbdrv/asmcommon.inc ****     sbrc    cnt, 4              ;[42] all handshake tokens have bit 4 set
 162:usbdrv/asmcommon.inc ****     rjmp    sendCntAndReti      ;[43] 47 + 16 = 63 until SOP
 163:usbdrv/asmcommon.inc ****     sts     usbTxLen1, x1       ;[44] x1 == USBPID_NAK from above
 164:usbdrv/asmcommon.inc ****     ldi     YL, lo8(usbTxBuf1)  ;[46]
 165:usbdrv/asmcommon.inc ****     ldi     YH, hi8(usbTxBuf1)  ;[47]
 166:usbdrv/asmcommon.inc ****     rjmp    usbSendAndReti      ;[48] 50 + 12 = 62 until SOP
 167               	#endif
 261               	---------------------------
 262               	; Transmitting data
 263               	;----------------------------------------------------------------------------
 264               	
 265               	bitstuff0:                  ;1 (for branch taken)
 266               	    eor     x1, x4          ;1
 267:usbdrv/usbdrvasm12.inc ****     ldi     x2, 0           ;1
 268:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 <-- out
 269:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff0       ;2 branch back 2 cycles earlier
 270:usbdrv/usbdrvasm12.inc **** bitstuff1:                  ;1 (for branch taken)
 271               	    eor     x1, x4          ;1
 272:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff1       ;2 we know that C is clear, jump back to do OUT and ror 0 into x2
 273:usbdrv/usbdrvasm12.inc **** bitstuff2:                  ;1 (for branch taken)
 274               	    eor     x1, x4          ;1
 275:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff2       ;2 jump back 4 cycles earlier and do out and ror 0 into x2
 276:usbdrv/usbdrvasm12.inc **** bitstuff3:                  ;1 (for branch taken)
 277               	    eor     x1, x4          ;1
 278:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff3       ;2 jump back earlier and ror 0 into x2
 279:usbdrv/usbdrvasm12.inc **** bitstuff4:                  ;1 (for branch taken)
 280               	    eor     x1, x4          ;1
 281:usbdrv/usbdrvasm12.inc ****     ldi     x2, 0           ;1
 282:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 <-- out
 283:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff4       ;2 jump back 2 cycles earlier
 284:usbdrv/usbdrvasm12.inc **** 
 285               	sendNakAndReti:                 ;0 [-19] 19 cycles until SOP
 286               	    ldi     x3, USBPID_NAK      ;1 [-18]
 287:usbdrv/usbdrvasm12.inc ****     rjmp    usbSendX3           ;2 [-16]
 288:usbdrv/usbdrvasm12.inc **** sendAckAndReti:                 ;0 [-19] 19 cycles until SOP
 289               	    ldi     x3, USBPID_ACK      ;1 [-18]
 290:usbdrv/usbdrvasm12.inc ****     rjmp    usbSendX3           ;2 [-16]
 291:usbdrv/usbdrvasm12.inc **** sendCntAndReti:                 ;0 [-17] 17 cycles until SOP
 292               	    mov     x3, cnt             ;1 [-16]
 293:usbdrv/usbdrvasm12.inc **** usbSendX3:                      ;0 [-16]
 294               	    ldi     YL, 20              ;1 [-15] 'x3' is R20
 295:usbdrv/usbdrvasm12.inc ****     ldi     YH, 0               ;1 [-14]
 296:usbdrv/usbdrvasm12.inc ****     ldi     cnt, 2              ;1 [-13]
 297:usbdrv/usbdrvasm12.inc **** ;   rjmp    usbSendAndReti      fallthrough
 298               	
 299               	; USB spec says:
 300               	; idle = J
 301               	; J = (D+ = 0), (D- = 1) or USBOUT = 0x01
 302               	; K = (D+ = 1), (D- = 0) or USBOUT = 0x02
 303               	; Spec allows 7.5 bit times from EOP to SOP for replies (= 60 cycles)
 304               	
 305               	;usbSend:
 306               	;pointer to data in 'Y'
 307               	;number of bytes in 'cnt' -- including sync byte
 308               	;uses: x1...x4, shift, cnt, Y
 309               	;Numbers in brackets are time since first bit of sync pattern is sent
 310               	usbSendAndReti:             ;0 [-13] timing: 13 cycles until SOP
 311               	    in      x2, USBDDR      ;1 [-12]
 312:usbdrv/usbdrvasm12.inc ****     ori     x2, USBMASK     ;1 [-11]
 313:usbdrv/usbdrvasm12.inc ****     sbi     USBOUT, USBMINUS;2 [-9] prepare idle state; D+ and D- must have been 0 (no pullups)
 314:usbdrv/usbdrvasm12.inc ****     in      x1, USBOUT      ;1 [-8] port mirror for tx loop
 315:usbdrv/usbdrvasm12.inc ****     out     USBDDR, x2      ;1 [-7] <- acquire bus
 316:usbdrv/usbdrvasm12.inc **** ; need not init x2 (bitstuff history) because sync starts with 0
 317               	    push    x4              ;2 [-5]
 318:usbdrv/usbdrvasm12.inc ****     ldi     x4, USBMASK     ;1 [-4] exor mask
 319:usbdrv/usbdrvasm12.inc ****     ldi     shift, 0x80     ;1 [-3] sync byte is first byte sent
 320:usbdrv/usbdrvasm12.inc **** txLoop:                     ;       [62]
 321               	    sbrs    shift, 0        ;1 [-2] [62]
 322:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [-1] [63]
 323:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [0] <-- out bit 0
 324:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [1]
 325:usbdrv/usbdrvasm12.inc ****     ror     x2              ;1 [2]
 326:usbdrv/usbdrvasm12.inc **** didStuff0:
 327               	    cpi     x2, 0xfc        ;1 [3]
 328:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff0       ;1 [4]
 329:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [5]
 330:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [6]
 331:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [7]
 332:usbdrv/usbdrvasm12.inc **** didStuff1:
 333               	    out     USBOUT, x1      ;1 [8] <-- out bit 1
 334:usbdrv/usbdrvasm12.inc ****     ror     x2              ;1 [9]
 335:usbdrv/usbdrvasm12.inc ****     cpi     x2, 0xfc        ;1 [10]
 336:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff1       ;1 [11]
 337:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [12]
 338:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [13]
 339:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [14]
 340:usbdrv/usbdrvasm12.inc **** didStuff2:
 341               	    ror     x2              ;1 [15]
 342:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [16] <-- out bit 2
 343:usbdrv/usbdrvasm12.inc ****     cpi     x2, 0xfc        ;1 [17]
 344:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff2       ;1 [18]
 345:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [19]
 346:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [20]
 347:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [21]
 348:usbdrv/usbdrvasm12.inc **** didStuff3:
 349               	    ror     x2              ;1 [22]
 350:usbdrv/usbdrvasm12.inc ****     cpi     x2, 0xfc        ;1 [23]
 351:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [24] <-- out bit 3
 352:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff3       ;1 [25]
 353:usbdrv/usbdrvasm12.inc ****     nop2                    ;2 [27]
 354:usbdrv/usbdrvasm12.inc ****     ld      x3, y+          ;2 [29]
 355:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [30]
 356:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [31]
 357:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [32] <-- out bit 4
 358:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [33]
 359:usbdrv/usbdrvasm12.inc ****     ror     x2              ;1 [34]
 360:usbdrv/usbdrvasm12.inc **** didStuff4:
 361               	    cpi     x2, 0xfc        ;1 [35]
 362:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff4       ;1 [36]
 363:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [37]
 364:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [38]
 365:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [39]
 366:usbdrv/usbdrvasm12.inc **** didStuff5:
 367               	    out     USBOUT, x1      ;1 [40] <-- out bit 5
 368:usbdrv/usbdrvasm12.inc ****     ror     x2              ;1 [41]
 369:usbdrv/usbdrvasm12.inc ****     cpi     x2, 0xfc        ;1 [42]
 370:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff5       ;1 [43]
 371:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [44]
 372:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [45]
 373:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [46]
 374:usbdrv/usbdrvasm12.inc **** didStuff6:
 375               	    ror     x2              ;1 [47]
 376:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [48] <-- out bit 6
 377:usbdrv/usbdrvasm12.inc ****     cpi     x2, 0xfc        ;1 [49]
 378:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff6       ;1 [50]
 379:usbdrv/usbdrvasm12.inc ****     sbrs    shift, 0        ;1 [51]
 380:usbdrv/usbdrvasm12.inc ****     eor     x1, x4          ;1 [52]
 381:usbdrv/usbdrvasm12.inc ****     ror     shift           ;1 [53]
 382:usbdrv/usbdrvasm12.inc **** didStuff7:
 383               	    ror     x2              ;1 [54]
 384:usbdrv/usbdrvasm12.inc ****     cpi     x2, 0xfc        ;1 [55]
 385:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [56] <-- out bit 7
 386:usbdrv/usbdrvasm12.inc ****     brsh    bitstuff7       ;1 [57]
 387:usbdrv/usbdrvasm12.inc ****     mov     shift, x3       ;1 [58]
 388:usbdrv/usbdrvasm12.inc ****     dec     cnt             ;1 [59]
 389:usbdrv/usbdrvasm12.inc ****     brne    txLoop          ;1/2 [60/61]
 390:usbdrv/usbdrvasm12.inc **** ;make SE0:
 391               	    cbr     x1, USBMASK     ;1 [61] prepare SE0 [spec says EOP may be 15 to 18 cycles]
 392:usbdrv/usbdrvasm12.inc ****     pop     x4              ;2 [63]
 393:usbdrv/usbdrvasm12.inc **** ;brackets are cycles from start of SE0 now
 394               	    out     USBOUT, x1      ;1 [0] <-- out SE0 -- from now 2 bits = 16 cycles until bus idle
 395:usbdrv/usbdrvasm12.inc **** ;2006-03-06: moved transfer of new address to usbDeviceAddr from C-Code to asm:
 396               	;set address only after data packet was sent, not after handshake
 397               	    lds     x2, usbNewDeviceAddr;2 [2]
 398:usbdrv/usbdrvasm12.inc ****     lsl     x2;             ;1 [3] we compare with left shifted address
 399:usbdrv/usbdrvasm12.inc ****     subi    YL, 20 + 2      ;1 [4] Only assign address on data packets, not ACK/NAK in x3
 400:usbdrv/usbdrvasm12.inc ****     sbci    YH, 0           ;1 [5]
 401:usbdrv/usbdrvasm12.inc ****     breq    skipAddrAssign  ;2 [7]
 402:usbdrv/usbdrvasm12.inc ****     sts     usbDeviceAddr, x2; if not skipped: SE0 is one cycle longer
 403:usbdrv/usbdrvasm12.inc **** skipAddrAssign:
 404               	;end of usbDeviceAddress transfer
 405               	    ldi     x2, 1<<USB_INTR_PENDING_BIT;1 [8] int0 occurred during TX -- clear pending flag
 406:usbdrv/usbdrvasm12.inc ****     USB_STORE_PENDING(x2)   ;1 [9]
 407:usbdrv/usbdrvasm12.inc ****     ori     x1, USBIDLE     ;1 [10]
 408:usbdrv/usbdrvasm12.inc ****     in      x2, USBDDR      ;1 [11]
 409:usbdrv/usbdrvasm12.inc ****     cbr     x2, USBMASK     ;1 [12] set both pins to input
 410:usbdrv/usbdrvasm12.inc ****     mov     x3, x1          ;1 [13]
 411:usbdrv/usbdrvasm12.inc ****     cbr     x3, USBMASK     ;1 [14] configure no pullup on both pins
 412:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x1      ;1 [15] <-- out J (idle) -- end of SE0 (EOP signal)
 413:usbdrv/usbdrvasm12.inc ****     out     USBDDR, x2      ;1 [16] <-- release bus now
 414:usbdrv/usbdrvasm12.inc ****     out     USBOUT, x3      ;1 [17] <-- ensure no pull-up resistors are active
 415:usbdrv/usbdrvasm12.inc ****     rjmp    doReturn
 416:usbdrv/usbdrvasm12.inc **** 
 417               	bitstuff5:                  ;1 (for branch taken)
 418               	    eor     x1, x4          ;1
 419:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff5       ;2 same trick as in bitstuff1...
 420:usbdrv/usbdrvasm12.inc **** bitstuff6:                  ;1 (for branch taken)
 421               	    eor     x1, x4          ;1
 422:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff6       ;2 same trick as above...
 423:usbdrv/usbdrvasm12.inc **** bitstuff7:                  ;1 (for branch taken)
 424               	    eor     x1, x4          ;1
 425:usbdrv/usbdrvasm12.inc ****     rjmp    didStuff7       ;2 same trick as above...
 426:usbdrv/usbdrvasm12.inc **** 
 427               	...
DEFINED SYMBOLS
usbdrv/usbdrvasm12.inc:41     .text:00000032 __vector_1
  usbdrv/usbdrvasm.S:166    .text:00000000 usbCrc16
  usbdrv/usbdrvasm.S:195    .text:0000002a usbCrc16Append
  usbdrv/usbdrvasm.S:174    .text:0000000e crcByteLoop
  usbdrv/usbdrvasm.S:190    .text:00000028 crcReady
  usbdrv/usbdrvasm.S:180    .text:00000018 crcBitLoop
  usbdrv/usbdrvasm.S:186    .text:00000022 crcNoXor
usbdrv/usbdrvasm12.inc:52     .text:00000038 waitForJ
usbdrv/usbdrvasm12.inc:55     .text:0000003c waitForK
usbdrv/usbdrvasm12.inc:73     .text:00000052 foundK
usbdrv/asmcommon.inc:101    .text:00000198 sofError
usbdrv/usbdrvasm12.inc:87     .text:00000066 haveTwoBitsK
usbdrv/usbdrvasm12.inc:188    .text:000000e8 rxbit2
usbdrv/usbdrvasm12.inc:114    .text:00000086 unstuff0
usbdrv/usbdrvasm12.inc:183    .text:000000e0 didUnstuff0
usbdrv/usbdrvasm12.inc:121    .text:00000090 unstuff1
usbdrv/usbdrvasm12.inc:192    .text:000000ee didUnstuff1
usbdrv/usbdrvasm12.inc:129    .text:0000009c unstuff2
usbdrv/usbdrvasm12.inc:201    .text:000000fe didUnstuff2
usbdrv/usbdrvasm12.inc:137    .text:000000a8 unstuff3
usbdrv/usbdrvasm12.inc:205    .text:00000104 didUnstuff3
usbdrv/usbdrvasm12.inc:143    .text:000000b0 unstuff4
usbdrv/usbdrvasm12.inc:212    .text:00000110 didUnstuff4
usbdrv/usbdrvasm12.inc:149    .text:000000b8 unstuff5
usbdrv/usbdrvasm12.inc:220    .text:0000011e didUnstuff5
usbdrv/usbdrvasm12.inc:155    .text:000000c0 unstuff6
usbdrv/usbdrvasm12.inc:228    .text:0000012c didUnstuff6
usbdrv/usbdrvasm12.inc:170    .text:000000c8 rxLoop
usbdrv/asmcommon.inc:55     .text:00000150 se0
usbdrv/asmcommon.inc:43     .text:00000148 overflow
usbdrv/usbdrvasm12.inc:236    .text:0000013a didUnstuff7
usbdrv/usbdrvasm12.inc:239    .text:0000013e unstuff7
usbdrv/asmcommon.inc:46     .text:0000014c ignorePacket
usbdrv/asmcommon.inc:94     .text:00000182 storeTokenAndReturn
usbdrv/asmcommon.inc:105    .text:000001a0 handleData
usbdrv/asmcommon.inc:124    .text:000001ca handleIn
usbdrv/asmcommon.inc:88     .text:00000182 handleSetupOrOut
usbdrv/asmcommon.inc:96     .text:00000186 doReturn
usbdrv/usbdrvasm12.inc:286    .text:00000218 sendNakAndReti
usbdrv/usbdrvasm12.inc:289    .text:0000021c sendAckAndReti
usbdrv/asmcommon.inc:154    .text:000001ea handleIn1
usbdrv/usbdrvasm12.inc:292    .text:00000220 sendCntAndReti
usbdrv/usbdrvasm12.inc:311    .text:00000228 usbSendAndReti
usbdrv/usbdrvasm12.inc:266    .text:000001fc bitstuff0
usbdrv/usbdrvasm12.inc:327    .text:00000242 didStuff0
usbdrv/usbdrvasm12.inc:271    .text:00000204 bitstuff1
usbdrv/usbdrvasm12.inc:333    .text:0000024c didStuff1
usbdrv/usbdrvasm12.inc:274    .text:00000208 bitstuff2
usbdrv/usbdrvasm12.inc:341    .text:0000025a didStuff2
usbdrv/usbdrvasm12.inc:277    .text:0000020c bitstuff3
usbdrv/usbdrvasm12.inc:349    .text:00000268 didStuff3
usbdrv/usbdrvasm12.inc:280    .text:00000210 bitstuff4
usbdrv/usbdrvasm12.inc:361    .text:0000027e didStuff4
usbdrv/usbdrvasm12.inc:294    .text:00000222 usbSendX3
usbdrv/usbdrvasm12.inc:321    .text:00000238 txLoop
usbdrv/usbdrvasm12.inc:367    .text:00000288 didStuff5
usbdrv/usbdrvasm12.inc:418    .text:000002de bitstuff5
usbdrv/usbdrvasm12.inc:375    .text:00000296 didStuff6
usbdrv/usbdrvasm12.inc:421    .text:000002e2 bitstuff6
usbdrv/usbdrvasm12.inc:383    .text:000002a4 didStuff7
usbdrv/usbdrvasm12.inc:424    .text:000002e6 bitstuff7
usbdrv/usbdrvasm12.inc:404    .text:000002c8 skipAddrAssign

UNDEFINED SYMBOLS
usbInputBufOffset
usbRxBuf
usbDeviceAddr
usbCurrentTok
usbRxLen
usbRxToken
usbTxLen
usbTxBuf
usbTxLen1
usbTxBuf1
usbNewDeviceAddr
